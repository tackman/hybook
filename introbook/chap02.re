= 言語ひとめぐり

本章では Hy の基本的な言語機能を解説していきます。

== 大原則

- Hy の構文はシンボルとフォームで構成される
- フォームは値を持つ（値を返す）
- フォームはシンボルの並びを()で囲んだものである
- フォームの 1 番目のシンボルは関数呼び出しをされ、残りは引数になる

多少の例外はあるものの、以上のルールを頭に入れるだけで Hy のコードは人力パースできてしまいます。
具体例を挙げてみましょう。

```
(+ 2 3 x)
```

上記のフォームでは、 「+」「2」「3」「x」がシンボルです。
このうち、+が先頭にあるため「+」が関数として呼び出され、残りの「2」「3」「x」が引数となります。

Python 風に書けば、以下のようになります。

```
plus_func(2, 3, x)
```

フォームは入れ子にもなります。

```
(F "some" (G x))

-> F("some", G(x))
```

== 使える記号とデリミター

Hy は一般的なプログラミング言語と異なり、名前への記号の使用にほとんど制約がありません。
絵文字も使いたければ使えます。以下は合法な名前の例です。

//emlist{
$*
2dConv
your-favorite_hifn
,,,
++C++;
*->
CamelCase
snake_case
💩💩
//}

名前付けへの制約で大きな特徴は、Hy では使用可能な文字がホワイトリスト式ではなく
ブラックリスト式な点でしょう。そのため、上記のような自由な名前付けができます。
原則として名前に含められない、ブラックリスト入りの記号は下記のものです。

//emlist{
. (ドット)
  （半角スペース）
` （バッククオート）
' （クオート）
先頭の " （ダブルクオート。文字列になる）
//}

「原則として」と奥歯に挟まった言い方をしているのは、
リーダーマクロなどの黒魔術を使えばあらゆる行為は合法にできるからです。
本書での解説はしませんが、必要な時に人はそこに導かれると思います。

== 関数定義

Built-in にある defn マクロを使うことで関数定義が可能です。
((defun ではありません。Common Lisp とのキーワード衝突が回避されているため、これを利用して
無理矢理 Common Lisp とインンターオペをするという手法も存在します))

//emlist{
(defn name [x y z]
  (form1)
  (form2)
  ...
  ret-value)
//}

対応する Python コードはこういう感じになるでしょう。

//emlist{
def name(x, y, z):
    form1()
    form2()
    ...
    return ret-value
//}

おおむね Python と 1 対 1 に対応していますが、返り値の書き方だけは多少異なります。
Hy では defn 内のコードパスで一番最後に評価された値が返り値になります。（Scala などと同様の方式です）
Python では明示的に return した値のみが返り値になりますが、
Hy では全ての関数が値を返すため、Python では return が不要だった場合についても
明示的に返り値を書く必要があります。

== 代入

setv という代入用の built-in があります。

//emlist{
(setv new-val "代入する値")

-> new_val = '代入する値'
//}

この setv は None を返しますが、Python3.8 のセイウチ演算子に対応した
値を返す版の setx もあります。

//emlist{
(setv a (setv x "Hy, world!"))

-> a = (x := 'Hy, world!')
//}

setx は Python3.8 上での実行が必要になります。

== 各種データの生成

=== tuple

タプルは , （カンマ）を使って生成します。

//emlist{
(, "str" 123)

-> ('str', 123)
//}

タプルを使った代入にも対応しています。

//emlist{
(defn f [] (, "returns" "value"))

(setv (, a b) (f))

(print a b) ;;; returns value
//}

=== dictionary

{} で囲むと辞書型になります。((カッコとシンボルを並べるのが原則の Hy で、dict の記法は例外の 1 つです))

//emlist{
(setv d {"key" "Value" :key 1234})

-> d = {"key" : "Value, HySymbol("key") : 1234}
//}

{key1 value1 key2 value2 ...} のように、key と value を交互に並べていきます。
Python のようにコロン及びカンマでの区切りはありません。

{} 内の要素が奇数だとコンパイルエラーになります。

=== list

[] で囲むとリストになります。これも数少ない例外的な記法の 1 つです。

//emlist{
(setv ary [1 2 4 6])

-> ary = [1, 2, 4, 6]
//}

list, dictionary ともに値の取得は get を使います。

//emlist{
(get d "key") ;;; value
(get ary 2) ;;; 4
//}

Python と異なり、x[i]のようにインデックス参照をして値を取得することはできません。

//emlist{
(setv x ary[2])
//}

のように書いた場合、下記のようにパースされます。

//emlist{
(setv x ary (list 2))
//}

この場合は setv が 2 つの引数（代入先と値）しか取ることを許していないため、コンパイルエラーになってくれます。
しかし、関数の返り値で ary[2] のようにした場合は、ary の 2 番目の要素 ではなく [2] というリストが返り値になります。
慣れてくるとそもそもこのような書き方はしなくなりますが、Python から来たばかりの人はハマることがあるかもしれません。

=== 文字列

ダブルクオートで囲むと文字列になります。Python と異なり、シングルクオートには Lisp 特有の用途（quote）があるため
必ずダブルクオートになります。quote / unquote についてはマクロの解説時に詳述します。

//emlist{
"string literal"

-> 'string literal'
//}

=== attribute へのアクセス . (ドット)

ドットは Python と同じような使い方で attribute へのアクセスができます。

(import )

=== シンボル :

: (コロン)から始まる名前は symbol になります。
関数のキーワード呼び出しなどで使われます。また、定数値として必要だけど値自体には意味がない時などにも使えます。

== コメント

; (セミコロン)から始まる行はコメントになります。また、セミコロン以降は行末までコメントになります。
文法的には以上ですが、Lisp の作法として

; ->
;; ->
;;; ->

のような使い分けがあります。

== Python との相互利用

Hy のデータ型は Python のデータ型のスーパーセットになっています。
そのため Python のモジュールを import した上で、全ての内容を利用可能です。

モジュールのインポートは import 文を使います。

//emlist{
(import torch)
(import [numpy :as np])

;;; from module_name import some_class には対応していません

(torch.randn 3 2) ;;; -> [[0.3134, 0.66134, 0.234265], [0.12312,0.6781,0.89138]]
//}
