= パフォーマンスの考察

HyはPythonのフロントエンド「のようなもの」です。
元より速くはないPythonランタイムの上で、
さらにHyの層が加わるとなるとパフォーマンスが気になるのは人情だと思います。

本章では、Hyのパフォーマンスとその実用上の意味について検討していきます。

== Hy ランタイムの概要

Hy のコンパイラが呼び出された時、

 1. Hy ソースのパース：Hy の AST を生成
 2. Hy の AST を Python の AST に変換
 3. Python AST を Python バイトコードに変換
 4. Python バイトコードを Python ランタイムで実行

という処理が行われます。

以上から、次のような性質が予想されるでしょう。

 * 実行速度のスループットは Python と同等にななる
 * 立ち上げ時にコンパイルの分オーバーヘッドが発生する

=== 本当に Python と同等の速度なのか

「原理的には Python と同等の実行速度になる」のですが、原理は現実の前に汚されがちです。
hy2py で Python ソースコードに変換したものを読むと、潜在的に速度が落ちる要素が見えたりします。

//emlist{
例1：マクロ展開形
hyxxxx_yyyyy(annovar(x))
のような式が生成されることがあります。


例2：シンボル
:name
↓↓↓
HySymbol("name")

のように、オブジェクト生成を伴う式にコンパイルされています。
//}

一方で、defn や derclass など Python と 1 対 1 に対応する機能を用いただけの場合は、
極めて素直な Python コードが生成されます。生で Python を書いた場合と見分けがつかないでしょう。

//emlist{
(defn tarai [x y z]
  (if (<= x y) y
      (tarai (tarai (- x 1) y z) (tarai (- y 1) z x) (tarai (- z 1) x y))))

# hy2py で出力されるコード
def tarai(x, y, z):
    return y if x <= y else tarai(tarai(x - 1, y, z), tarai(y - 1, z, x),
        tarai(z - 1, x, y))

//}

まとめると、

 * Hy 特有の凝った機能を使うと（潜在的に）遅いコードが出力されがち。特にマクロの利用で顕著になります
 * Python にある機能を使う限り、Python そのもののようなコードが出力される

ということになります。

=== 現実に遅くなるのか

では Hy の実際の利用環境で、Python に比べて意味のある速度差が出るのでしょうか？
筆者としては、答えはノーだと考えています。

HyExpression が入ることで速度差が出るようなケースは、次の 2 つが考えられます。

 1. 重い計算処理でループの内側にあるような場合
 2. レイテンシが重要な処理

1 番目に関しては、ここでは高速なコードが生成されるように気を使う必要があります。
ただしこれは、Hy に限らずあらゆるプログラミング言語で同様です。
「高速」とされているプログラミング言語、例えば C++や Java であっても、
ループの内側で不用意な処理をすると大幅に低速化することには代わりはありません。
つまり、Hy の速度云々よりもプログラマーの責任の問題だと言えます。

2 番目に関しては、そのような処理を（生の）Python で書くこと自体がほとんど場合に間違った選択です。
1 番目のケースも含めて、高度なチューニングやレイテンシの削減が必要な場合は、
Cython を導入する・部分的に C++で書くなどの解決法を検討するべきです。

ところで、Python には numpy をはじめコンピューティングのための高度なライブラリが充実しています。
これらのライブラリでは、「ループの外側」を Python で書くだけで高速に、
また多くの場合並列化をした処理を行ってくれます。

Hy を、ひいては Python を利用するそもそもの動機はこれらのライブラリにあることが多いでしょう。
つまり、現実の問題を解く場合には、上記のような高速化について考える必要がある場合はあまりないはずです。
もしあったら、問題設定から見直した方がいいかもしれません。

総合して、Hy は Python で十分な場合には十分は速度を出すし、そうでない時には不足した速度しか出せません。
Hy はあくまで Python 世界の住人です。能力も限界も、Python そのものであると考えればいいでしょう。

== ベンチマーク

いくつかのケースについて、筆者の手元でベンチマークを取った結果を見てみます。
Hy のコードと、それを hy2py した Python コードの実行で比較していきます。

=== 立ち上げ速度

大量ののクラスがあるソースファイルの実行です。

//emlist{
(defclass ClassNameXXXX [][]
  (defn f [x] (+ x 0.123434))) ;; 生成時に加算する数値をランダム生成

;; このクラスを10万個並べている
;; hy2pyで下記のようになる

class ClassNameXXXX:
    def f(x):
        return x + 0.12345

//}


//table[bench1][ベンチマーク結果]{
クラス数	Hy	Python
------------
100	1s 以下	1s以下
1000	1s 以下	1s 以下
10000	1s	1s 以下
100000	10s	1s 以下
//}

実用的な範囲では Hy と Python で大差はありませんが、1 万行を超えたあたりからは Python が有意に速くなります。
ソースファイルにデータを埋め込むようなエッジケースでは、Hy であることで問題が発生しそうです。

=== CPU だけの計算

上で挙げた竹内関数（たらい回し関数）を計算してみます。

//emlist{
(tarai 14 6 0)

tarai(14, 6, 0)
//}

//table[bench2][竹内関数の実行時間]{
Hy	Python
------------
39.75	39.7
//}

有意差はないと言っていいでしょう。

=== メモリや IO を含む計算：深層学習

MNIST データセットに対して、（バニラ）GAN で画像生成をするモデルの学習をする深層学習のコードに対して、
学習速度の計測をしてみます。コードは （引用元）の Python コードと、これを Hy に同内容で書き直したものを使っています。

このコードは、以下のような要素を含んでいます。

 * CUDA の利用：GPU 上での演算と、GPU との間で転送が発生します
 * メインメモリの読み書き
 * ファイル IO（MNIST データの読み込み）

なお、このベンチマークは epoch に対してのみ行っているので、Hy のコンパイル時間は含まれていません。

//table[bench3][10epochの実行時間]{
Hy	Python
------------
89.49s	89.28s
//}

実行時間で 0.2%ほど Python が速くなっていますが、有意な差はないと言えるでしょう。
天気のいい日に実行したら Hy の方が速くなるかもしれない範囲です。

== 結論と未解決事項

白魔術を使う限り、Hy であることが理由でパフォーマンスの問題は起きません。
Hy で問題になる場合は、Python でも問題が起きるはずです。

マクロをはじめ黒魔術を駆使した場合に何が起こるかについては、今回は未検証です。
Hy のコンパイラをクラッシュさせるマクロくらいは頑張れば作れそうな気はするので、
オモチャがどれくらいで壊れるか遊んでみたい方は挑戦してみてはいかがでしょうか？

== 参考文献

本章で解説した Hy コンパイラの動作は、概要に絞った説明になっています。
Hy 公式ドキュメントでは、より詳細なコンパイラの動作の解説があります。

http://docs.hylang.org/en/stable/language/internals.html#hy-internal-theory

マクロの展開タイミングなど、より詳細な情報はこちらから読むことができます。
